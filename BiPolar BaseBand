close all; clear all; clc;
% Bipolar, Baseband PAM transmitter
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Signal Generation
% INPUT:  none
% OUTPUT: binary data
temp      = 'ILoveMATLAB';
data      = text2bits(temp);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modulation Scheme
% INPUT: data
% OUPUT: modulated values, x
inputVec  = [0   1];
outputVec = [-1  1];
x         = lut(data, inputVec, outputVec);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input Signal Parameters
Pulse_duration_in_seconds = 0.2;
Time_per_symbol = Pulse_duration_in_seconds/2; % Assignmentrequirementtrying to packtomanysymbols
Symbols_sent_per_second = 10;
Numbers_sent_per_symbol = 50; % Upsample rate- adding in 0s for padding
Numbers_sent_per_second = Numbers_sent_per_symbol * Symbols_sent_per_second; 
Numbers_sent_per_pulse = Numbers_sent_per_second * Pulse_duration_in_seconds;
Number_of_symbols_sent = length(x);
Number_of_numbers_sent = Number_of_symbols_sent * Numbers_sent_per_symbol;
Time_to_send_all = Time_per_symbol * Number_of_symbols_sent;

Tp = Pulse_duration_in_seconds / 2; % Half of the pulse duration
SPB = Numbers_sent_per_symbol;
dt = 1 / Numbers_sent_per_second; % Sampling period
Ts = 1 / Symbols_sent_per_second; % Symbol period
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generate SRRC pulse
pulse = SRRC(0.5,Numbers_sent_per_symbol,Number_of_symbols_sent)
t = 0:(Number_of_numbers_sent+length(pulse)-2); % room for convolution
t = dt * t; % Convert from index of number sent to time (in seconds) sent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Oversample and then Convolute 
UpSample_data = zeros(1, Number_of_numbers_sent);
for i = 0:(Number_of_symbols_sent-1)
   % Copy the signal of -1 and +1 into a list of zeros with correct spacing
   UpSample_data(Numbers_sent_per_symbol*i + 1) = x(i+1);
end
y = conv(UpSample_data, pulse);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Upconvert
wc = 2 * pi * 20; % 20Hz modulation
z = cos(wc*t(1:length(y)));
y1 = y;
y = y .* z;
y2 = y;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sigmaList = (0:0.2:.8);
errorRateSlow = zeros(length(sigmaList));

for i = 1:length(sigmaList)
    sigma = sigmaList(i);
    rSlow = y + sigma * randn(1, length(y)); % Add noise to sent signal

    % DownConvert
    rSlow = rSlow.*z;

    % Matched Filter acts like downsampling
    rSlowFiltered = conv(rSlow, pulse); % Use the pulse as a filter for what we received
    t_rConv = linspace(0, dt*(length(rSlowFiltered)-1), length(rSlowFiltered));

    % Adjust time vectors
    t_rSlow = linspace(-dt*(length(pulse)-1), dt*(length(rSlow)-length(pulse)), length(rSlow));
    t_rConv = linspace(-dt*(length(pulse)-1), dt*(length(rSlowFiltered)-length(pulse)), length(rSlowFiltered));

    % Create a new figure for each sigma value
    figure;
    title('Received Signal with Noise, Matched Filter Output, and Bit Decisions');
    xlabel('Time');
    ylabel('Amplitude');
    hold on;

    % Plot Signal with Noise
    %plot(t_rSlow, rSlow, 'b');

    % Plot Matched Filter Output
    plot(t_rConv, rSlowFiltered, 'g');

    % Find Bit Indexs
    start_point = length(pulse) - 1;
    sample_points = start_point : SPB : (start_point + SPB*(length(data)-1));
    sample_points = sample_points(sample_points <= length(rSlowFiltered));

    % Bit Decisions
    data_out = (rSlowFiltered(sample_points) > 0);
    len_data_out = length(sample_points);
    t_data_out = t_rConv(sample_points);
    stem(t_data_out, (2*data_out)-1, 'r');

    % Calculate Error Rate
    errorRateSlow(i) = sum(data_out ~= data(1:length(data_out))) / length(data_out);
    fprintf('Error rate: %.2f%%\n', errorRateSlow(i) * 100);

    hold off;
end

% Plot the Error Rate vs. Sigma
figure(23);
plot(sigmaList, errorRateSlow);
title('Error Rate vs. Noise Level');
xlabel('Sigma');
ylabel('Error Rate');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Translate to ascii text
% INPUT: Bits
% OUTPUT: Character vector, message_out
message_out = binvector2str(data_out)



function h = SRRC(alpha, N, Lp)
   % alpha = rolloff factor
   % N = 1/2 of the quantity of numbers that will be sent per pulse
   % Lp = number of pulses we'd like to leave room for
   n = [(-N * Lp) : (N * Lp)] + 10^-9;
   % Add epsilon to the n values to avoid numerical problems

   % Plug into time domain formula for the SRRC pulse shape
   h = (1 / sqrt(N)) * (sin(pi * (1 - alpha) * n / N) + ...
      (4 * alpha * n / N) .* cos(pi * (1 + alpha) * n / N)) ... 
      ./ (pi * n / N .* (1 - (4 * alpha * n / N).^2))
end


